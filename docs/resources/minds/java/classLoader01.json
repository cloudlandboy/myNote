{"root":{"data":{"text":"Java类加载器(ClassLoader)","hyperlink":null,"expandState":"expand","hyperlinkTitle":null},"children":[{"data":{"text":"类加载的5个过程","expandState":"collapse"},"children":[{"data":{"text":"加载","expandState":"collapse"},"children":[{"data":{"text":"加载class文件"},"children":[]}]},{"data":{"text":"验证","expandState":"collapse"},"children":[{"data":{"text":"验证class文件，确保虚拟机自身安全。","expandState":"collapse"},"children":[{"data":{"text":"文件格式验证"},"children":[]},{"data":{"text":"元数据验证"},"children":[]},{"data":{"text":"字节码验证"},"children":[]},{"data":{"text":"符号引用验证"},"children":[]}]}]},{"data":{"text":"准备","expandState":"collapse"},"children":[{"data":{"text":"类变量分配内存并设置初始值（static修饰的字段）","expandState":"collapse"},"children":[{"data":{"text":"static int i=5，这里只初始化为0，最后一步初始化时再赋值为5"},"children":[]},{"data":{"text":"不包含final，final字段在编译时已经赋值完毕"},"children":[]},{"data":{"text":"不包含实例变量，实例变量在java堆中"},"children":[]},{"data":{"text":"类变量分配在方法区中"},"children":[]}]}]},{"data":{"text":"解析","expandState":"collapse"},"children":[{"data":{"text":"将常量池中的符号引用替换为直接引用的过程"},"children":[]}]},{"data":{"text":"初始化","expandState":"collapse"},"children":[{"data":{"text":"初始化超类"},"children":[]},{"data":{"text":"执行静态初始化器"},"children":[]},{"data":{"text":"类变量初始化"},"children":[]}]}]},{"data":{"text":"四种类加载器","expandState":"collapse"},"children":[{"data":{"text":"启动类加载器（Bootstrap）","expandState":"collapse"},"children":[{"data":{"text":"加载JVM自身需要的类"},"children":[]},{"data":{"text":"用C++实现，是虚拟机的一部分"},"children":[]},{"data":{"text":"负责将<JAVA_HOME>/lib路径下的核心类或 -Xbootclasspath参数指定的路径下的jar包加载到内存中"},"children":[]},{"data":{"text":"按照文件名识别加载jar包，如rt.jar","expandState":"collapse"},"children":[{"data":{"text":"如果文件名不被虚拟机识别，丢到lib下也没用"},"children":[]}]},{"data":{"text":"只加载包名为java,javax,sun等开头的类"},"children":[]}]},{"data":{"text":"扩展类加载器（ExtClassLoader）","expandState":"collapse"},"children":[{"data":{"text":"sun.misc.Launcher&ExtClassLoader"},"children":[]},{"data":{"text":"是Launcher的静态内部类，JAVA实现"},"children":[]},{"data":{"text":"加载<JAVA_HOME>/lib/ext目录家或 -D java.ext.dir指定路径中的类"},"children":[]}]},{"data":{"text":"系统类加载器（AppClassLoader）","expandState":"collapse"},"children":[{"data":{"text":"sun.misc.Launcher$AppClassLoader"},"children":[]},{"data":{"text":"加载java -classpath或-D java.class.path指定路径下的类库，即classpath路径"},"children":[]},{"data":{"text":"一般情况下默认使用该加载器"},"children":[]},{"data":{"text":"通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器"},"children":[]}]},{"data":{"text":"自定义类加载器","expandState":"collapse"},"children":[{"data":{"text":"父类是AppClassLoader"},"children":[]},{"data":{"text":"一般继承URLClassLoader，不用自己写findClass()方法"},"children":[]}]}]},{"data":{"text":"显式加载与隐式加载","expandState":"collapse","layout":null},"children":[{"data":{"text":"指的是jvm把class文件加载到内存的方式","layout":null},"children":[]},{"data":{"text":"显式加载：在代码中通过调用ClassLoader加载class对象","layout":null,"expandState":"collapse"},"children":[{"data":{"text":"Class.forName(name)","layout":null},"children":[]},{"data":{"text":"this.getClass().getClassLoader().loadClass()","layout":null},"children":[]}]},{"data":{"text":"隐式加载：不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中","layout":null,"note":"在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中"},"children":[]}]},{"data":{"text":"双亲委派模式","expandState":"collapse"},"children":[{"data":{"text":"除了顶层的启动类加载器，其余的类加载器都先尝试由父类加载器加载","expandState":"collapse"},"children":[{"data":{"text":"组合关系，非继承关系"},"children":[]},{"data":{"text":"层级由低到高：自定义类加载器->系统类加载器->扩展类加载器->启动类加载器"},"children":[]}]},{"data":{"text":"java 1.2 后引入"},"children":[]},{"data":{"text":"优势","expandState":"collapse","note":"使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。 相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 如果读者\n有兴趣的话，可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编\n译，但永远无法被加载运行"},"children":[{"data":{"text":"Java类获得了带有优先级的层次关系"},"children":[]},{"data":{"text":"安全，核心api中定义的类型不会被随意替换"},"children":[]},{"data":{"text":"使用核心API包名编写自定义类，加载时会报异常","expandState":"collapse"},"children":[{"data":{"text":"java.lang.SecurityException: Prohibited package name: xxx"},"children":[]}]}]},{"data":{"text":"双亲委派模型的破坏者","expandState":"collapse"},"children":[{"data":{"text":"线程上下文类加载器","expandState":"collapse"},"children":[{"data":{"text":"通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器"},"children":[]},{"data":{"text":"如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器"},"children":[]},{"data":{"text":"初始线程的上下文类加载器是系统类加载器（AppClassLoader）"},"children":[]},{"data":{"text":"在线程中运行的代码可以通过此类加载器来加载类和资源，"},"children":[]}]}]}]},{"data":{"text":"类与类加载器","expandState":"collapse"},"children":[{"data":{"text":"两个Class是否是同一个类对象","expandState":"collapse"},"children":[{"data":{"text":"包名必须一致"},"children":[]},{"data":{"text":"加载这个类的ClassLoader必须一致","expandState":"collapse"},"children":[{"data":{"text":"需要覆写loadClass()方法，否则同名类不会加载"},"children":[]},{"data":{"text":"可以用该特性实现热部署功能"},"children":[]}]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}