{"root":{"data":{"text":"java面对对象","expandState":"expand"},"children":[{"data":{"text":"基本定义","expandState":"collapse"},"children":[{"data":{"text":"1","expandState":"collapse"},"children":[{"data":{"text":"类","expandState":"collapse"},"children":[{"data":{"text":"对事物、逻辑、算法或概念的抽象。描述一类对象的行为和状态。"},"children":[]}]},{"data":{"text":"对象（实例）","expandState":"collapse"},"children":[{"data":{"text":"对象是类的一个实例（对象不是找个女朋友），有状态和行为。"},"children":[]}]},{"data":{"text":"引用","expandState":"collapse"},"children":[{"data":{"text":"java中，一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。”"},"children":[]}]},{"data":{"text":"构造方法","expandState":"collapse"},"children":[{"data":{"text":"新建对象时，执行的一个特殊方法"},"children":[]},{"data":{"text":"在创建一个对象的时候，至少要调用一个构造方法"},"children":[]},{"data":{"text":"构造方法的名称必须与类同名，一个类可以有多个构造方法"},"children":[]}]},{"data":{"text":"this","expandState":"collapse"},"children":[{"data":{"text":"引用当前对象"},"children":[]},{"data":{"text":"构造方法之间调用"},"children":[]}]},{"data":{"text":"方法重载overload","expandState":"collapse"},"children":[{"data":{"text":"同名不同参"},"children":[]}]}]},{"data":{"text":"2","expandState":"collapse"},"children":[{"data":{"text":"抽象类","expandState":"collapse"},"children":[{"data":{"text":"作用","expandState":"collapse"},"children":[{"data":{"text":"为子类提供通用代码"},"children":[]},{"data":{"text":"为子类提供通用方法的定义"},"children":[]}]},{"data":{"text":"注意点","expandState":"collapse"},"children":[{"data":{"text":"抽象类不能创建对象"},"children":[]},{"data":{"text":"包含抽象方法的类，必须是抽象类"},"children":[]},{"data":{"text":"抽象类中，不一定有抽象方法"},"children":[]}]}]},{"data":{"text":"final","expandState":"collapse"},"children":[{"data":{"text":"最终不可变的"},"children":[]},{"data":{"text":"修饰变量、方法、类"},"children":[]}]},{"data":{"text":"static（静态）","expandState":"collapse"},"children":[{"data":{"text":"静态变量属于类，可以成为“类变量”"},"children":[]},{"data":{"text":"非静态成员属于实例"},"children":[]},{"data":{"text":"静态成员通常使用类名直接调用"},"children":[]},{"data":{"text":"被static修饰的成员将最优先加载到内存"},"children":[]}]}]},{"data":{"text":"接口","expandState":"collapse"},"children":[{"data":{"text":"作用","expandState":"collapse"},"children":[{"data":{"text":"结构设计工具，用来解耦合"},"children":[]}]},{"data":{"text":"极端的抽象类"},"children":[]},{"data":{"text":"用interface替代class"},"children":[]},{"data":{"text":"用implements替代extends"},"children":[]},{"data":{"text":"接口中只能定义","expandState":"collapse"},"children":[{"data":{"text":"公共的常量"},"children":[]},{"data":{"text":"公共的抽象方法"},"children":[]},{"data":{"text":"公共的内部类、内部接口"},"children":[]}]}]}]},{"data":{"text":"内部类","expandState":"collapse"},"children":[{"data":{"text":"定义","expandState":"collapse"},"children":[{"data":{"text":"定义在类内部，方法内部或局部代码块中的类"},"children":[]}]},{"data":{"text":"非静态内部类","expandState":"collapse"},"children":[{"data":{"text":"非静态内部类依赖于外部类对象存在"},"children":[]},{"data":{"text":"在非静态内部类中，不能定义静态成员"},"children":[]}]},{"data":{"text":"静态内部类","expandState":"collapse"},"children":[{"data":{"text":"使用static修饰的成员内部类，称之为静态内部类"},"children":[]},{"data":{"text":"静态内部类只能访问外部类的静态成员"},"children":[]},{"data":{"text":"不能直接访问外部类的非静态成员"},"children":[]}]},{"data":{"text":"局部内部类","expandState":"collapse"},"children":[{"data":{"text":"定义","expandState":"collapse"},"children":[{"data":{"text":"声明在方法内部的类"},"children":[]},{"data":{"text":"局部类型，只能在局部使用"},"children":[]},{"data":{"text":"但它的实例，可以转为父类型传递出去"},"children":[]}]},{"data":{"text":"注意","expandState":"collapse"},"children":[{"data":{"text":"不可以使用任何访问权限修饰符"},"children":[]},{"data":{"text":"不可以直接访问局部变量（方法的参数等效于局部变量）"},"children":[]},{"data":{"text":"如果一定需要访问，则需要使用final对局部变量进行修饰"},"children":[]}]}]},{"data":{"text":"成员内部类","expandState":"collapse"},"children":[{"data":{"text":"在类（外部类）的内部，且与外部类的成员是“同一级别”的"},"children":[]}]},{"data":{"text":"匿名内部类","expandState":"collapse"},"children":[{"data":{"text":"直接创建已知的类的子类的对象，则该对象的类型就是匿名内部类"},"children":[]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}