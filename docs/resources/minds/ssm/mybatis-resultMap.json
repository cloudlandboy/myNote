{"root":{"data":{"text":"resultMap子元素","expandState":"expand"},"children":[{"data":{"text":"id & result","expandState":"collapse"},"children":[{"data":{"text":"例子"},"children":[{"data":{"text":"<id property=\"id\" column=\"post_id\"/>\r\n<result property=\"subject\" column=\"post_subject\"/>","background":"#c7edcc"},"children":[]}]},{"data":{"text":"结果映射最基本内容"},"children":[]},{"data":{"text":"都映射一个单独列的值到简单数据类型(字符 串,整型,双精度浮点数,日期等)的单独属性或字段"},"children":[]},{"data":{"text":"这两者之间的唯一不同是 id 表示的结果将是当比较对象实例时用到的标识属性"},"children":[]}]},{"data":{"text":"构造方法constructor","expandState":"collapse"},"children":[{"data":{"text":"例子","expandState":"collapse"},"children":[{"data":{"text":"<constructor>\r\n   <idArg column=\"id\" javaType=\"int\"/>\r\n   <arg column=\"username\" javaType=\"String\"/>\r\n   <arg column=\"age\" javaType=\"_int\"/>\r\n</constructor>","background":"#c7edcc"},"children":[]}]},{"data":{"text":"对应构造方法","note":"```\n\npublic class User {\n  //...\n  public User(Integer id, String username, int age) {\n  \t//...\n  }\n  //...\n}\n\n```"},"children":[]}]},{"data":{"text":"关联association","expandState":"collapse"},"children":[{"data":{"text":"例子","expandState":"collapse"},"children":[{"data":{"text":"<association property=\"author\" column=\"blog_author_id\" javaType=\"Author\">\r\n  <id property=\"id\" column=\"author_id\"/>\r\n  <result property=\"username\" column=\"author_username\"/>\r\n</association>","background":"#c7edcc"},"children":[]}]},{"data":{"text":"对应类型关系","expandState":"collapse"},"children":[{"data":{"text":"public class Blog {\n   //...\n   private Author author;\n//...\n}","background":"#c7edcc"},"children":[]},{"data":{"text":"一个博客有一个用户"},"children":[]}]},{"data":{"text":"关联的嵌套查询","expandState":"collapse","note":"我们有两个查询语句:一个来加载博客,另外一个来加载作者,而且博客的结果映射描 述了“selectAuthor”语句应该被用来加载它的 author 属性。\n\n其他所有的属性将会被自动加载,假设它们的列和属性名相匹配。\n\n这种方式很简单, 但是对于大型数据集合和列表将不会表现很好。 问题就是我们熟知的 “N+1 查询问题”。概括地讲,N+1 查询问题可以是这样引起的:\n\n你执行了一个单独的 SQL 语句来获取结果列表(就是“+1”)。\n对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是“N”)。\n这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。\n\nMyBatis 能延迟加载这样的查询就是一个好处,因此你可以分散这些语句同时运行的消 耗。然而,如果你加载一个列表,之后迅速迭代来访问嵌套的数据,你会调用所有的延迟加 载,这样的行为可能是很糟糕的。"},"children":[{"data":{"text":"<resultMap id=\"blogResult\" type=\"Blog\">\n  <association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"selectAuthor\"/>\n</resultMap>\n\n<select id=\"selectBlog\" resultMap=\"blogResult\">\n  SELECT * FROM BLOG WHERE ID = #{id}\n</select>\n\n<select id=\"selectAuthor\" resultType=\"Author\">\n  SELECT * FROM AUTHOR WHERE ID = #{id}\n</select>","background":"#c7edcc"},"children":[]},{"data":{"text":"两个查询语句:一个来加载博客,另外一个来加载作者"},"children":[]}]},{"data":{"text":"关联的嵌套结果","expandState":"collapse"},"children":[{"data":{"id":"bztukr67y1s0","created":1578835786140,"text":" ","image":"https://i.postimg.cc/LXJtMWpH/20200112212850.png","imageTitle":"20200112212850.png","imageSize":{"width":200,"height":48}},"children":[]},{"data":{"text":"注意","expandState":"collapse"},"children":[{"data":{"text":"id元素在嵌套结果映射中扮演着非 常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。"},"children":[]}]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}