{"root":{"data":{"text":"mapper的xml文件（四）"},"children":[{"data":{"text":"Result Maps","expandState":"collapse"},"children":[{"data":{"text":"幕后创建ResultMap","priority":1,"expandState":"collapse"},"children":[{"data":{"text":" ","image":"https://i.postimg.cc/8PB5Kb6s/20200112205548.png","imageTitle":"20200112205548.png","imageSize":{"width":200,"height":60}},"children":[]},{"data":{"text":"说明","expandState":"collapse"},"children":[{"data":{"text":"这些情况下,MyBatis 会在幕后自动创建一个 ResultMap,基于属性名来映射列到 JavaBean 的属性上。"},"children":[]}]},{"data":{"text":"注意","expandState":"collapse"},"children":[{"data":{"text":"如果列名没有精确匹配,你可以在列名上使用 select 字句的别名(一个 基本的 SQL 特性)来匹配标签"},"children":[]},{"data":{"text":"<select id=\"selectUsers\" resultType=\"User\">\r\n  select\r\n    user_id             as \"id\",\r\n    user_name           as \"userName\",\r\n    hashed_password     as \"hashedPassword\"\r\n  from some_table\r\n  where id = #{id}\r\n</select>","background":"#c7edcc"},"children":[]}]}]},{"data":{"text":"外部创建ResultMap","priority":2,"expandState":"collapse"},"children":[{"data":{"text":" ","image":"https://i.postimg.cc/FFx5wCTt/20200112205801.png","imageTitle":"20200112205801.png","imageSize":{"width":200,"height":35}},"children":[]},{"data":{"text":"20200112205903.png","image":"https://i.postimg.cc/vHHFy7K4/20200112205903.png","imageTitle":"20200112205903.png","imageSize":{"width":200,"height":47}},"children":[]}]},{"data":{"text":"以上是解决列名不匹配的两种方式"},"children":[]}]},{"data":{"text":"高级结果映射","expandState":"collapse","note":"高级结果映射\n\nMyBatis 创建的一个想法:数据库不用永远是你想要的或需要它们是什么样的。而我们 最喜欢的数据库最好是第三范式或 BCNF 模式,但它们有时不是。如果可能有一个单独的 数据库映射,所有应用程序都可以使用它,这是非常好的,但有时也不是。结果映射就是 MyBatis 提供处理这个问题的答案。\n\n比如,我们如何映射下面这个语句?\n\n<!-- Very Complex Statement -->\n<select id=\"selectBlogDetails\" resultMap=\"detailedBlogResultMap\">\n  select\n       B.id as blog_id,\n       B.title as blog_title,\n       B.author_id as blog_author_id,\n       A.id as author_id,\n       A.username as author_username,\n       A.password as author_password,\n       A.email as author_email,\n       A.bio as author_bio,\n       A.favourite_section as author_favourite_section,\n       P.id as post_id,\n       P.blog_id as post_blog_id,\n       P.author_id as post_author_id,\n       P.created_on as post_created_on,\n       P.section as post_section,\n       P.subject as post_subject,\n       P.draft as draft,\n       P.body as post_body,\n       C.id as comment_id,\n       C.post_id as comment_post_id,\n       C.name as comment_name,\n       C.comment as comment_text,\n       T.id as tag_id,\n       T.name as tag_name\n  from Blog B\n       left outer join Author A on B.author_id = A.id\n       left outer join Post P on B.id = P.blog_id\n       left outer join Comment C on P.id = C.post_id\n       left outer join Post_Tag PT on PT.post_id = P.id\n       left outer join Tag T on PT.tag_id = T.id\n  where B.id = #{id}\n</select>\n\n你可能想把它映射到一个智能的对象模型,包含一个作者写的博客,有很多的博文,每 篇博文有零条或多条的评论和标签。 下面是一个完整的复杂结果映射例子 (假设作者, 博客, 博文, 评论和标签都是类型的别名) 我们来看看, 。 但是不用紧张, 我们会一步一步来说明。 当天最初它看起来令人生畏,但实际上非常简单。\n\n<!-- Very Complex Result Map -->\n<resultMap id=\"detailedBlogResultMap\" type=\"Blog\">\n  <constructor>\n    <idArg column=\"blog_id\" javaType=\"int\"/>\n  </constructor>\n  <result property=\"title\" column=\"blog_title\"/>\n  <association property=\"author\" javaType=\"Author\">\n    <id property=\"id\" column=\"author_id\"/>\n    <result property=\"username\" column=\"author_username\"/>\n    <result property=\"password\" column=\"author_password\"/>\n    <result property=\"email\" column=\"author_email\"/>\n    <result property=\"bio\" column=\"author_bio\"/>\n    <result property=\"favouriteSection\" column=\"author_favourite_section\"/>\n  </association>\n  <collection property=\"posts\" ofType=\"Post\">\n    <id property=\"id\" column=\"post_id\"/>\n    <result property=\"subject\" column=\"post_subject\"/>\n    <association property=\"author\" javaType=\"Author\"/>\n    <collection property=\"comments\" ofType=\"Comment\">\n      <id property=\"id\" column=\"comment_id\"/>\n    </collection>\n    <collection property=\"tags\" ofType=\"Tag\" >\n      <id property=\"id\" column=\"tag_id\"/>\n    </collection>\n    <discriminator javaType=\"int\" column=\"draft\">\n      <case value=\"1\" resultType=\"DraftPost\"/>\n    </discriminator>\n  </collection>\n</resultMap>"},"children":[{"data":{"text":"例子","expandState":"collapse"},"children":[{"data":{"text":" ","image":"https://i.postimg.cc/Z5PJKYcR/20200112211034.png","imageTitle":"20200112211034.png","imageSize":{"width":200,"height":112}},"children":[]},{"data":{"id":"bztude2p6xs0","created":1578835209080,"text":" ","image":"https://i.postimg.cc/1z9sgxCK/20200112211136.png","imageTitle":"20200112211136.png","imageSize":{"width":200,"height":101}},"children":[]}]},{"data":{"text":"resultMap 元素","expandState":"collapse"},"children":[{"data":{"text":"属性","expandState":"collapse"},"children":[{"data":{"text":"id","expandState":"collapse"},"children":[{"data":{"text":"当前命名空间中的一个唯一标识，用于标识一个result map."},"children":[]}]},{"data":{"text":"type","expandState":"collapse"},"children":[{"data":{"text":"类的全限定名, 或者一个类型别名"},"children":[]}]},{"data":{"text":"autoMapping","expandState":"collapse"},"children":[{"data":{"text":"如果设置这个属性，MyBatis将会为这个ResultMap开启或者关闭自动映射。这个属性会覆盖全局的属性autoMappingBehavior。默认值为：unset。"},"children":[]}]}]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}