{"root":{"data":{"text":"SpringAOP","expandState":"expand","note":"AOP（Aspect-OrientedProgramming，面向方面编程）\n可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n\n而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。 ","hyperlink":"https://www.jianshu.com/p/7b74ad5ffb76","hyperlinkTitle":""},"children":[{"data":{"text":"OOP与AOP","expandState":"collapse"},"children":[{"data":{"text":"概念","expandState":"collapse"},"children":[{"data":{"text":"AOP（Aspect-OrientedProgramming，面向方面编程）","expandState":"expand"},"children":[]},{"data":{"text":"OOP（Object-Oriented Programing，面向对象编程）","expandState":"expand"},"children":[]}]},{"data":{"text":"方向","expandState":"collapse"},"children":[{"data":{"text":"OOP定义从上到下的关系","expandState":"expand"},"children":[]},{"data":{"text":"AOP定义从左到右的关系","expandState":"expand"},"children":[]}]}]},{"data":{"text":"两个部分","expandState":"collapse","note":"作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来"},"children":[{"data":{"text":"核心关注点","expandState":"collapse"},"children":[{"data":{"text":"业务处理的主要流程","expandState":"expand"},"children":[]}]},{"data":{"text":"横切关注点","expandState":"collapse"},"children":[{"data":{"text":"与业务主要流程关系不大的部分","expandState":"expand"},"children":[]},{"data":{"text":"经常发生在核心关注点的多处，而各处都基本相似","expandState":"expand"},"children":[]},{"data":{"text":"比如权限认证、日志、事务处理","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bzug8ilmm7s0","created":1578896891528,"text":"aop应用场景","expandState":"collapse"},"children":[{"data":{"id":"bzug8jhf0xc0","created":1578896893451,"text":"性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。"},"children":[]},{"data":{"id":"bzug8jhfmw00","created":1578896893452,"text":"缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。"},"children":[]},{"data":{"id":"bzug8jhg6kg0","created":1578896893452,"text":"软件破解，使用AOP修改软件的验证类的判断逻辑。"},"children":[]},{"data":{"id":"bzug8jhfpq00","created":1578896893452,"text":"记录日志，在方法执行前后记录系统日志。"},"children":[]},{"data":{"id":"bzug8jhfqb40","created":1578896893452,"text":"工作流系统，工作流系统需要将业务代码和流程引擎代码混合在一起执行，那么我们可以使用AOP将其分离，并动态挂接业务。"},"children":[]},{"data":{"id":"bzug8jhfyv40","created":1578896893452,"text":"权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。"},"children":[]}]},{"data":{"id":"bzuh07jgra80","created":1578899061650,"text":"aop重要概念","expandState":"collapse"},"children":[{"data":{"id":"bzuh0kgk3nk0","created":1578899089772,"text":" ","image":"https://upload-images.jianshu.io/upload_images/4120002-2b45edfd6ac8b120.png","imageTitle":"","imageSize":{"width":200,"height":179}},"children":[]}]},{"data":{"id":"bzufr3475y00","created":1578895525632,"text":"3种日志处理","expandState":"collapse"},"children":[{"data":{"id":"bzufr347cr40","created":1578895525632,"text":"硬代码编写","expandState":"collapse"},"children":[{"data":{"id":"bzufr347lds0","created":1578895525633,"text":"优缺点","expandState":"expand"},"children":[{"data":{"id":"bzufr347ssg0","created":1578895525633,"text":"处理代码相同， 代码强耦合"},"children":[]}]},{"data":{"id":"bzufr347wso0","created":1578895525633,"text":"","image":"https://i.postimg.cc/2SQwtm9D/20201013140501.png","imageTitle":"20201013140501.png","imageSize":{"width":200,"height":89}},"children":[]}]},{"data":{"id":"bzufr347kbc0","created":1578895525633,"text":"抽离方法，代码复用","expandState":"collapse"},"children":[{"data":{"id":"bzufr348ecw0","created":1578895525634,"text":"优缺点"},"children":[{"data":{"id":"bzufr348ghc0","created":1578895525634,"text":"手动插入方法，代码强耦合"},"children":[]}]},{"data":{"id":"bzufr348ark0","created":1578895525634,"text":"","image":"https://i.postimg.cc/s23cd8bZ/20201013140601.png","imageTitle":"20201013140601.png","imageSize":{"width":200,"height":115}},"children":[]}]},{"data":{"id":"bzufr348dzk0","created":1578895525634,"text":"aop","expandState":"collapse"},"children":[{"data":{"id":"bzufr348hj40","created":1578895525634,"text":"优缺点","expandState":"collapse"},"children":[{"data":{"id":"bzufr348tyo0","created":1578895525635,"text":"横向的功能抽离出来形成一个独立的模块，低耦合"},"children":[]}]},{"data":{"id":"bzufr3497tk0","created":1578895525635,"text":"","image":"https://i.postimg.cc/rwXjgzJj/20201013140602.png","imageTitle":"20201013140602.png","imageSize":{"width":200,"height":103}},"children":[]}]}]},{"data":{"id":"bzugjmr8jwo0","created":1578897762580,"text":"spring aop原理","note":"通过前面介绍可以知道：AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但 AOP 代理中的方法与目标对象的方法存在差异：AOP 方法在特定切入点添加了增强处理，并回调了目标对象的方法。","image":"","imageTitle":"","imageSize":"","expandState":"collapse"},"children":[{"data":{"id":"bzugz2w3dco0","created":1578898973165,"text":" ","image":"https://upload-images.jianshu.io/upload_images/4120002-a8b78f02932e8924.png","imageTitle":"","imageSize":{"width":200,"height":164}},"children":[]}]},{"data":{"id":"bzugmn1b0js0","created":1578897998282,"text":"aop开发","note":"Spring 的 `AOP` 代理由 Spring 的 `IoC` 容器负责生成、管理，其依赖关系也由 IoC 容器负责管理。因此，AOP 代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由 IoC 容器的依赖注入提供。","expandState":"collapse"},"children":[{"data":{"id":"bzugn7a7e1s0","created":1578898042356,"text":"aop开发时，其中需要程序员参与的只有 3 个部分","expandState":"collapse"},"children":[{"data":{"id":"bzugnkar0qw0","created":1578898070687,"text":"定义普通业务组件。"},"children":[]},{"data":{"id":"bzugnlhezi80","created":1578898073267,"text":"定义切入点，一个切入点可能横切多个业务组件。"},"children":[]},{"data":{"id":"bzugnlnki200","created":1578898073639,"text":"定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作。"},"children":[]}]},{"data":{"id":"bzuh39b6alc0","created":1578899300594,"text":" ","image":"https://i.postimg.cc/gcT94y1W/20200113144137.png","imageTitle":"20200113144137.png","imageSize":{"width":200,"height":121}},"children":[]},{"data":{"id":"bzuh3imuqbs0","created":1578899320892,"text":" ","image":"https://i.postimg.cc/PJcBxh1x/20200113144223.png","imageTitle":"20200113144223.png","imageSize":{"width":200,"height":10}},"children":[]}]},{"data":{"id":"bzugrdeflmo0","created":1578898369129,"text":"两种动态代理方式","note":"Spring默认采取的动态代理机制实现AOP，当动态代理不可用时（代理类无接口）会使用CGlib机制。\n\nSpring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。","expandState":"collapse"},"children":[{"data":{"id":"bzugry463k80","created":1578898414220,"text":"JDK动态代理","note":"- JDK动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。\n\n- Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。\n"},"children":[]},{"data":{"id":"bzugsquj1s80","created":1578898476764,"text":"CGLib动态代理","note":"CGLib全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java类与实现Java接口，CGLib封装了asm，可以再运行期动态生成新的class。和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib创建动态代理。\n"},"children":[]}]},{"data":{"id":"bzugua22vuw0","created":1578898596944,"text":"拦截器与过滤器","note":"在`web.xml`中注册了`TestFilter1`和`TestFilter2`。然后在spring的配置文件中配置了`BaseInterceptor`和`TestInterceptor`。得到的结果如下图所示。从图中可以看出，拦截器和过滤器都横切了业务方法，看似符合aop的思想。","expandState":"collapse"},"children":[{"data":{"id":"bzugxv6chz40","created":1578898878007,"text":" ","image":"https://upload-images.jianshu.io/upload_images/4120002-2cf4f1c6351c104d.png","imageTitle":"","imageSize":{"width":200,"height":102}},"children":[]},{"data":{"id":"bzugvcwwpuo0","created":1578898681526,"text":"Filter过滤器：拦截web访问url地址。"},"children":[]},{"data":{"id":"bzugvcwwqww0","created":1578898681526,"text":"Interceptor拦截器：拦截以 .action结尾的url，拦截Action的访问。"},"children":[]},{"data":{"id":"bzugvcwxpsw0","created":1578898681527,"text":"Spring AOP拦截器：只能拦截Spring管理Bean的访问（业务层Service）"},"children":[]},{"data":{"id":"bzugwhdb3ps0","created":1578898769588,"text":" ","image":"https://upload-images.jianshu.io/upload_images/4120002-414b3a2c8e51a540.png","imageTitle":"","imageSize":{"width":200,"height":94}},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}